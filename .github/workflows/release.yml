name: Automatic Release Creation

on:
  workflow_dispatch:

jobs:
  detect-last-release:
    runs-on: ubuntu-latest
    outputs:
      last_release: ${{ steps.last-release.outputs.hash }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get last release hash
        id: last-release
        run: |
          HASH=$(git rev-list --tags --max-count=1 || echo "HEAD~1")
          echo "hash=${HASH}" >> $GITHUB_OUTPUT
          echo "Using last release hash: ${HASH}"

  create-tag-name:
    runs-on: ubuntu-latest
    outputs:
      tag_name: ${{ steps.last-release.outputs.tag}}
    steps:
      - name: Get last release hash
        id: last-release
        run: |
          DATE=$(date +%Y.%m.%d)
          echo "tag=v${DATE}" >> $GITHUB_OUTPUT
          echo "Using tag: v${DATE}"

  detect-packages:
    needs: [detect-last-release]
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.find-packages.outputs.packages }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install uv
        uses: astral-sh/setup-uv@v5

      - name: Find packages
        id: find-packages
        working-directory: src
        run: |
          cat << 'EOF' > find_packages.py
          import json
          import os
          import subprocess
          from itertools import chain
          from pathlib import Path

          packages = []

          print("Starting package detection...")
          print(f"Using LAST_RELEASE: {os.environ['LAST_RELEASE']}")

          # Find all directories containing package.json or pyproject.toml
          paths = chain(Path('.').glob('*/package.json'), Path('.').glob('*/pyproject.toml'))
          for path in paths:
                print(f"\nChecking path: {path}")
                # Check for changes in .py or .ts files
                # Run git diff from the specific directory
                cmd = ['git', 'diff', '--name-only', f'{os.environ["LAST_RELEASE"]}..HEAD', '--', '.']
                result = subprocess.run(cmd, capture_output=True, text=True, cwd=path.parent)

                # Check if any .py or .ts files were changed
                changed_files = result.stdout.strip().split('\n')
                print(f"Changed files found: {changed_files}")

                has_changes = any(f.endswith(('.py', '.ts')) for f in changed_files if f)
                if has_changes:
                    print(f"Adding package: {path.parent}")
                    packages.append(str(path.parent))

          print(f"\nFinal packages list: {packages}")

          # Write output
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"packages={json.dumps(packages)}\n")
          EOF

          LAST_RELEASE=${{ needs.detect-last-release.outputs.last_release }} uv run --script --python 3.12 find_packages.py

  create-tag:
    needs: [detect-packages, create-tag-name]
    if: fromJson(needs.detect-packages.outputs.packages)[0] != null
    runs-on: ubuntu-latest
    environment: release
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4

      - name: Create tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Configure git
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

          # Get packages array
          PACKAGES='${{ needs.detect-packages.outputs.packages }}'

          if [ "$(echo "$PACKAGES" | jq 'length')" -gt 0 ]; then
            # Create and push tag
            git tag -a "${{ needs.create-tag-name.outputs.tag_name }}" -m "Release ${{ needs.create-tag-name.outputs.tag_name }}"
            git push origin "${{ needs.create-tag-name.outputs.tag_name }}"
          else
            echo "No packages need release"
          fi

      - name: Create release
        env:
          GH_TOKEN: ${{ secrets.RELEASE_TOKEN }}
        run: |
          PACKAGES='${{ needs.detect-packages.outputs.packages }}'

          if [ "$(echo "$PACKAGES" | jq 'length')" -gt 0 ]; then
            # Generate comprehensive release notes
            {
              echo "# Release ${{ needs.create-tag-name.outputs.tag_name }}"
              echo ""
              echo "## Updated Packages"
              echo "$PACKAGES" | jq -r '.[]' | while read -r package; do
                echo "- $package"
              done
            } > notes.md
            # Create GitHub release
            gh release create "${{ needs.create-tag-name.outputs.tag_name }}" \
              --title "Release ${{ needs.create-tag-name.outputs.tag_name }}" \
              --notes-file notes.md
          else
            echo "No packages need release"
          fi
