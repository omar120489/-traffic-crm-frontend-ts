class m extends Error{response;request;options;constructor(e,o,t){const r=e.status||e.status===0?e.status:"",n=e.statusText??"",i=`${r} ${n}`.trim(),a=i?`status code ${i}`:"an unknown error";super(`Request failed with ${a}: ${o.method} ${o.url}`),this.name="HTTPError",this.response=e,this.request=o,this.options=t}}class k extends Error{name="NonError";value;constructor(e){let o="Non-error value was thrown";try{typeof e=="string"?o=e:e&&typeof e=="object"&&"message"in e&&typeof e.message=="string"&&(o=e.message)}catch{}super(o),this.value=e}}const T=(()=>{let s=!1,e=!1;const o=typeof globalThis.ReadableStream=="function",t=typeof globalThis.Request=="function";if(o&&t)try{e=new globalThis.Request("https://empty.invalid",{body:new globalThis.ReadableStream,method:"POST",get duplex(){return s=!0,"half"}}).headers.has("Content-Type")}catch(r){if(r instanceof Error&&r.message==="unsupported BodyInit type")return!1;throw r}return s&&!e})(),A=typeof globalThis.AbortController=="function",j=typeof globalThis.AbortSignal=="function"&&typeof globalThis.AbortSignal.any=="function",C=typeof globalThis.ReadableStream=="function",v=typeof globalThis.FormData=="function",x=["get","post","put","patch","head","delete"],O={json:"application/json",text:"text/*",formData:"multipart/form-data",arrayBuffer:"*/*",blob:"*/*",bytes:"*/*"},y=2147483647,L=new TextEncoder().encode("------WebKitFormBoundaryaxpyiPgbbPti10Rw").length,S=Symbol("stop"),U={json:!0,parseJson:!0,stringifyJson:!0,searchParams:!0,prefixUrl:!0,retry:!0,timeout:!0,hooks:!0,throwHttpErrors:!0,onDownloadProgress:!0,onUploadProgress:!0,fetch:!0,context:!0},$={next:!0},D={method:!0,headers:!0,body:!0,mode:!0,credentials:!0,cache:!0,redirect:!0,referrer:!0,referrerPolicy:!0,integrity:!0,keepalive:!0,signal:!0,window:!0,duplex:!0},N=s=>{if(!s)return 0;if(s instanceof FormData){let e=0;for(const[o,t]of s)e+=L,e+=new TextEncoder().encode(`Content-Disposition: form-data; name="${o}"`).length,e+=typeof t=="string"?new TextEncoder().encode(t).length:t.size;return e}if(s instanceof Blob)return s.size;if(s instanceof ArrayBuffer)return s.byteLength;if(typeof s=="string")return new TextEncoder().encode(s).length;if(s instanceof URLSearchParams)return new TextEncoder().encode(s.toString()).length;if("byteLength"in s)return s.byteLength;if(typeof s=="object"&&s!==null)try{const e=JSON.stringify(s);return new TextEncoder().encode(e).length}catch{return 0}return 0},q=(s,e,o)=>{let t,r=0;return s.pipeThrough(new TransformStream({transform(n,i){if(i.enqueue(n),t){r+=t.byteLength;let a=e===0?0:r/e;a>=1&&(a=1-Number.EPSILON),o?.({percent:a,totalBytes:Math.max(e,r),transferredBytes:r},t)}t=n},flush(){t&&(r+=t.byteLength,o?.({percent:1,totalBytes:Math.max(e,r),transferredBytes:r},t))}}))},I=(s,e)=>{if(!s.body)return s;if(s.status===204)return new Response(null,{status:s.status,statusText:s.statusText,headers:s.headers});const o=Math.max(0,Number(s.headers.get("content-length"))||0);return new Response(q(s.body,o,e),{status:s.status,statusText:s.statusText,headers:s.headers})},H=(s,e,o)=>{if(!s.body)return s;const t=N(o??s.body);return new Request(s,{duplex:"half",body:q(s.body,t,e)})},h=s=>s!==null&&typeof s=="object",f=(...s)=>{for(const e of s)if((!h(e)||Array.isArray(e))&&e!==void 0)throw new TypeError("The `options` argument must be an object");return w({},...s)},P=(s={},e={})=>{const o=new globalThis.Headers(s),t=e instanceof globalThis.Headers,r=new globalThis.Headers(e);for(const[n,i]of r.entries())t&&i==="undefined"||i===void 0?o.delete(n):o.set(n,i);return o};function d(s,e,o){return Object.hasOwn(e,o)&&e[o]===void 0?[]:w(s[o]??[],e[o]??[])}const E=(s={},e={})=>({beforeRequest:d(s,e,"beforeRequest"),beforeRetry:d(s,e,"beforeRetry"),afterResponse:d(s,e,"afterResponse"),beforeError:d(s,e,"beforeError")}),z=(s,e)=>{const o=new URLSearchParams;for(const t of[s,e])if(t!==void 0)if(t instanceof URLSearchParams)for(const[r,n]of t.entries())o.append(r,n);else if(Array.isArray(t))for(const r of t){if(!Array.isArray(r)||r.length!==2)throw new TypeError("Array search parameters must be provided in [[key, value], ...] format");o.append(String(r[0]),String(r[1]))}else if(h(t))for(const[r,n]of Object.entries(t))n!==void 0&&o.append(r,String(n));else{const r=new URLSearchParams(t);for(const[n,i]of r.entries())o.append(n,i)}return o},w=(...s)=>{let e={},o={},t={},r;const n=[];for(const i of s)if(Array.isArray(i))Array.isArray(e)||(e=[]),e=[...e,...i];else if(h(i)){for(let[a,c]of Object.entries(i)){if(a==="signal"&&c instanceof globalThis.AbortSignal){n.push(c);continue}if(a==="context"){if(c!=null&&(!h(c)||Array.isArray(c)))throw new TypeError("The `context` option must be an object");e={...e,context:c==null?{}:{...e.context,...c}};continue}if(a==="searchParams"){c==null?r=void 0:r=r===void 0?c:z(r,c);continue}h(c)&&a in e&&(c=w(e[a],c)),e={...e,[a]:c}}h(i.hooks)&&(t=E(t,i.hooks),e.hooks=t),h(i.headers)&&(o=P(o,i.headers),e.headers=o)}return r!==void 0&&(e.searchParams=r),n.length>0&&(n.length===1?e.signal=n[0]:j?e.signal=AbortSignal.any(n):e.signal=n.at(-1)),e.context===void 0&&(e.context={}),e},B=s=>x.includes(s)?s.toUpperCase():s,M=["get","put","head","delete","options","trace"],J=[408,413,429,500,502,503,504],F=[413,429,503],R={limit:2,methods:M,statusCodes:J,afterStatusCodes:F,maxRetryAfter:Number.POSITIVE_INFINITY,backoffLimit:Number.POSITIVE_INFINITY,delay:s=>.3*2**(s-1)*1e3,jitter:void 0,retryOnTimeout:!1},V=(s={})=>{if(typeof s=="number")return{...R,limit:s};if(s.methods&&!Array.isArray(s.methods))throw new Error("retry.methods must be an array");if(s.statusCodes&&!Array.isArray(s.statusCodes))throw new Error("retry.statusCodes must be an array");return{...R,...s}};class g extends Error{request;constructor(e){super(`Request timed out: ${e.method} ${e.url}`),this.name="TimeoutError",this.request=e}}async function W(s,e,o,t){return new Promise((r,n)=>{const i=setTimeout(()=>{o&&o.abort(),n(new g(s))},t.timeout);t.fetch(s,e).then(r).catch(n).then(()=>{clearTimeout(i)})})}async function X(s,{signal:e}){return new Promise((o,t)=>{e&&(e.throwIfAborted(),e.addEventListener("abort",r,{once:!0}));function r(){clearTimeout(n),t(e.reason)}const n=setTimeout(()=>{e?.removeEventListener("abort",r),o()},s)})}const K=(s,e)=>{const o={};for(const t in e)Object.hasOwn(e,t)&&!(t in D)&&!(t in U)&&(!(t in s)||t in $)&&(o[t]=e[t]);return o},Y=s=>s===void 0?!1:Array.isArray(s)?s.length>0:s instanceof URLSearchParams?s.size>0:typeof s=="object"?Object.keys(s).length>0:typeof s=="string"?s.trim().length>0:!!s;function G(s){return s instanceof m||s?.name===m.name}function Q(s){return s instanceof g||s?.name===g.name}class l{static create(e,o){const t=new l(e,o),r=async()=>{if(typeof t.#e.timeout=="number"&&t.#e.timeout>y)throw new RangeError(`The \`timeout\` option cannot be greater than ${y}`);await Promise.resolve();let a=await t.#d();for(const c of t.#e.hooks.afterResponse){const u=await c(t.request,t.#i(),t.#u(a.clone()),{retryCount:t.#s});u instanceof globalThis.Response&&(a=u)}if(t.#u(a),!a.ok&&t.#e.throwHttpErrors){let c=new m(a,t.request,t.#i());for(const u of t.#e.hooks.beforeError)c=await u(c,{retryCount:t.#s});throw c}if(t.#e.onDownloadProgress){if(typeof t.#e.onDownloadProgress!="function")throw new TypeError("The `onDownloadProgress` option must be a function");if(!C)throw new Error("Streams are not supported in your environment. `ReadableStream` is missing.");return I(a.clone(),t.#e.onDownloadProgress)}return a},i=(t.#e.retry.methods.includes(t.request.method.toLowerCase())?t.#h(r):r()).finally(async()=>{const a=t.#n,c=[];a&&!a.bodyUsed&&c.push(a.body?.cancel()),t.request.bodyUsed||c.push(t.request.body?.cancel()),await Promise.all(c)});for(const[a,c]of Object.entries(O))a==="bytes"&&typeof globalThis.Response?.prototype?.bytes!="function"||(i[a]=async()=>{t.request.headers.set("accept",t.request.headers.get("accept")||c);const u=await i;if(a==="json"){if(u.status===204)return"";const p=await u.text();return p===""?"":o.parseJson?o.parseJson(p):JSON.parse(p)}return u[a]()});return i}static#l(e){return e&&typeof e=="object"&&!Array.isArray(e)&&!(e instanceof URLSearchParams)?Object.fromEntries(Object.entries(e).filter(([,o])=>o!==void 0)):e}request;#r;#s=0;#t;#e;#n;#o;#a;constructor(e,o={}){if(this.#t=e,this.#e={...o,headers:P(this.#t.headers,o.headers),hooks:E({beforeRequest:[],beforeRetry:[],beforeError:[],afterResponse:[]},o.hooks),method:B(o.method??this.#t.method??"GET"),prefixUrl:String(o.prefixUrl||""),retry:V(o.retry),throwHttpErrors:o.throwHttpErrors!==!1,timeout:o.timeout??1e4,fetch:o.fetch??globalThis.fetch.bind(globalThis),context:o.context??{}},typeof this.#t!="string"&&!(this.#t instanceof URL||this.#t instanceof globalThis.Request))throw new TypeError("`input` must be a string, URL, or Request");if(this.#e.prefixUrl&&typeof this.#t=="string"){if(this.#t.startsWith("/"))throw new Error("`input` must not begin with a slash when using `prefixUrl`");this.#e.prefixUrl.endsWith("/")||(this.#e.prefixUrl+="/"),this.#t=this.#e.prefixUrl+this.#t}A&&j&&(this.#o=this.#e.signal??this.#t.signal,this.#r=new globalThis.AbortController,this.#e.signal=this.#o?AbortSignal.any([this.#o,this.#r.signal]):this.#r.signal),T&&(this.#e.duplex="half"),this.#e.json!==void 0&&(this.#e.body=this.#e.stringifyJson?.(this.#e.json)??JSON.stringify(this.#e.json),this.#e.headers.set("content-type",this.#e.headers.get("content-type")??"application/json"));const t=o.headers&&new globalThis.Headers(o.headers).has("content-type");if(this.#t instanceof globalThis.Request&&(v&&this.#e.body instanceof globalThis.FormData||this.#e.body instanceof URLSearchParams)&&!t&&this.#e.headers.delete("content-type"),this.request=new globalThis.Request(this.#t,this.#e),Y(this.#e.searchParams)){const n="?"+(typeof this.#e.searchParams=="string"?this.#e.searchParams.replace(/^\?/,""):new URLSearchParams(l.#l(this.#e.searchParams)).toString()),i=this.request.url.replace(/(?:\?.*?)?(?=#|$)/,n);this.request=new globalThis.Request(new globalThis.Request(i,{...this.request}),this.#e)}if(this.#e.onUploadProgress){if(typeof this.#e.onUploadProgress!="function")throw new TypeError("The `onUploadProgress` option must be a function");if(!T)throw new Error("Request streams are not supported in your environment. The `duplex` option for `Request` is not available.");this.request.body&&(this.request=H(this.request,this.#e.onUploadProgress,this.#e.body))}}#c(){const e=this.#e.retry.delay(this.#s);let o=e;return this.#e.retry.jitter===!0?o=Math.random()*e:typeof this.#e.retry.jitter=="function"&&(o=this.#e.retry.jitter(e),(!Number.isFinite(o)||o<0)&&(o=e)),Math.min(this.#e.retry.backoffLimit,o)}async#f(e){if(this.#s++,this.#s>this.#e.retry.limit)throw e;const o=e instanceof Error?e:new k(e);if(this.#e.retry.shouldRetry!==void 0){const t=await this.#e.retry.shouldRetry({error:o,retryCount:this.#s});if(t===!1)throw e;if(t===!0)return this.#c()}if(Q(e)&&!this.#e.retry.retryOnTimeout)throw e;if(G(e)){if(!this.#e.retry.statusCodes.includes(e.response.status))throw e;const t=e.response.headers.get("Retry-After")??e.response.headers.get("RateLimit-Reset")??e.response.headers.get("X-RateLimit-Retry-After")??e.response.headers.get("X-RateLimit-Reset")??e.response.headers.get("X-Rate-Limit-Reset");if(t&&this.#e.retry.afterStatusCodes.includes(e.response.status)){let r=Number(t)*1e3;Number.isNaN(r)?r=Date.parse(t)-Date.now():r>=Date.parse("2024-01-01")&&(r-=Date.now());const n=this.#e.retry.maxRetryAfter??r;return r<n?r:n}if(e.response.status===413)throw e}return this.#c()}#u(e){return this.#e.parseJson&&(e.json=async()=>this.#e.parseJson(await e.text())),e}async#h(e){try{return await e()}catch(o){const t=Math.min(await this.#f(o),y);if(this.#s<1)throw o;await X(t,this.#o?{signal:this.#o}:{});for(const r of this.#e.hooks.beforeRetry){const n=await r({request:this.request,options:this.#i(),error:o,retryCount:this.#s});if(n instanceof globalThis.Request){this.request=n;break}if(n instanceof globalThis.Response)return n;if(n===S)return}return this.#h(e)}}async#d(){this.#r?.signal.aborted&&(this.#r=new globalThis.AbortController,this.#e.signal=this.#o?AbortSignal.any([this.#o,this.#r.signal]):this.#r.signal,this.request=new globalThis.Request(this.request,{signal:this.#e.signal}));for(const o of this.#e.hooks.beforeRequest){const t=await o(this.request,this.#i(),{retryCount:this.#s});if(t instanceof Request){this.request=t;break}if(t instanceof Response)return t}const e=K(this.request,this.#e);return this.#n=this.request,this.request=this.#n.clone(),this.#e.timeout===!1?this.#e.fetch(this.#n,e):W(this.#n,e,this.#r,this.#e)}#i(){if(!this.#a){const{hooks:e,...o}=this.#e;this.#a=Object.freeze(o)}return this.#a}}/*! MIT License Â© Sindre Sorhus */const b=s=>{const e=(o,t)=>l.create(o,f(s,t));for(const o of x)e[o]=(t,r)=>l.create(t,f(s,r,{method:o}));return e.create=o=>b(f(o)),e.extend=o=>(typeof o=="function"&&(o=o(s??{})),b(f(s,o))),e.stop=S,e},Z=b();function _(s){const{baseUrl:e,getToken:o}=s,t=Z.create({prefixUrl:e.replace(/\/+$/,""),timeout:1e4,retry:{limit:2,methods:["get"],statusCodes:[408,413,429,500,502,503,504]},hooks:{beforeRequest:[async r=>{const n=typeof o=="function"?await o():o;n&&r.headers.set("Authorization",`Bearer ${n}`),r.headers.set("Content-Type","application/json")}],beforeError:[async r=>{const{response:n}=r;if(n){let i=null;try{i=await n.clone().json()}catch{}const a=(i?.message||i?.error||i?.detail)??n.statusText??r.message;r.message=a,r.status=n.status,r.body=i}return r}]}});return{listContacts:r=>t.get("contacts",{searchParams:r}).json(),getContact:r=>t.get(`contacts/${r}`).json(),createContact:r=>t.post("contacts",{json:r}).json(),updateContact:(r,n)=>t.patch(`contacts/${r}`,{json:n}).json(),deleteContact:r=>t.delete(`contacts/${r}`).json(),listLeads:r=>t.get("leads",{searchParams:r}).json(),getLead:r=>t.get(`leads/${r}`).json(),createLead:r=>t.post("leads",{json:r}).json(),updateLead:(r,n)=>t.patch(`leads/${r}`,{json:n}).json(),deleteLead:r=>t.delete(`leads/${r}`).json(),listDeals:r=>t.get("deals",{searchParams:r}).json(),getDeal:r=>t.get(`deals/${r}`).json(),createDeal:r=>t.post("deals",{json:r}).json(),updateDeal:(r,n)=>t.patch(`deals/${r}`,{json:n}).json(),deleteDeal:r=>t.delete(`deals/${r}`).json(),listCompanies:r=>t.get("companies",{searchParams:r}).json(),getCompany:r=>t.get(`companies/${r}`).json(),createCompany:r=>t.post("companies",{json:r}).json(),updateCompany:(r,n)=>t.patch(`companies/${r}`,{json:n}).json(),deleteCompany:r=>t.delete(`companies/${r}`).json()}}const ee="http://localhost:3000/api";async function te(){try{const s=localStorage.getItem("jwt");if(s)return s}catch(s){console.warn("[SDK] Failed to read JWT from localStorage:",s)}return null}const se=_({baseUrl:ee,getToken:te});export{se as a};
//# sourceMappingURL=sdk-Dtz1-FIW.js.map
